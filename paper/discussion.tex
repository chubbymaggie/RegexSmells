\section{Discussion}
\label{sec:discussion}

\subsection{Further Refactoring Opportunities}
A particular community (like Mozilla or some startup) may want to include regex refactoring into their coding standards.  We anticipate that having one preferred way to express a particular regex may increase regex understandability in the codebase for maintainers, leading to a reduction in errors related to misunderstanding regexes.

We looked at 5 groups that cover the most frequently used features, but other refactorings exist that deserve further study.  Here are a few:
\begin{description}
\item[Single line option]  \verb!'''(.|\n)+'''! is equivalent to \verb!(?s)'''(.)+'''!
\item[Multi line option]  \verb!(?m)G\n! is equivalent to \verb!(?m)G$!
\item[Multi line option]  \verb!(?i)[a-z]! is equivalent to \verb![A-Za-z]!
\item[Backreferences]  \verb!(X)q\1! is equivalent to \verb!(?P<name>X)q\g<name>!
\item[Word Boundaries]  \verb!\bZ! is equivalent to \verb!((?<=\w)(?=\W)|(?<=\W)(?=\w))Z!
\end{description}

One terribly obvious application of our refactorings is to search existing codebases for regex patterns that are candidates for refactoring, allowing a person to quickly go through a list of possible changes and improve the understandability of the regexes in their codebase.

Maintainers of code that is intentionally obfuscated for security purposes may want to develop regexes that they understand and then automatically transform them to equivalent but less understandable regexes.



\subsection{Threats to Validity}

\subsubsection{Internal}
We measure understandability of regexes using two metrics, matching and composition. However, these measures may not reflect actual understanding of the regex behavior. For this reason, we chose to use two metrics and present the analysis in the context of reading and writing regexes, but the threat remains.

\todoMid{what about the threat of too few examples per node?}

We treated unsure responses as omissions and did not count those against the participants. Thus, if a participant answered two strings correctly with match/not match, and marked the other three strings as unsure, then this was 2/2 correct, not 2/5.

\subsubsection{External}
Participants in our survey came from MTurk, which may not be representative of people who read and write regexes on a regular basis.

The regexes we used in the evaluation were inspired by those commonly found in Python code, which is just one language that has library support for regexes. Thus, we may have missed opportunities for other refactorings based on how programmers use regexes in other programming languages.

Our community analysis only focuses on the Python language. Note that because the vast majority of regex features are shared across most general programming languages (e.g., Java, C, C\#, or Ruby), a Python {pattern} will (almost always) behave the same when used in other languages, whereas a utilization is not universal in the same way (i.e., it may not compile in other languages, even with small modifications to function and flag names).
As an example, the {\tt re.MULTILINE} flag, or similar, is present in Python, Java, and C\#, but  the Python {\tt re.DOTALL} flag is not present in C\# though it has an equivalent flag in Java.
