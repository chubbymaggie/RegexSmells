\section{Discussion}
\label{sec:discussion}
\subsection{Opportunities For Future Work}
\paragraph{Reinforcing/Improving This Study}
Future work could completely cover all edges between equivalence class nodes.  It could also focus on gathering regular expressions from a particular project type (website, application, library) or maturity level (homework, small open source project, gigantic super-project like Google Chrome) and focus on gathering understandability data from participants most relevant to the selected focus.  Future work could also directly ask some users to identify what they believe to be the more understandable between two equivalent representations.  The specific regexes used to gage understandability could be pulled directly from the target community's project set (most frequently composed regexes, most buggy regexes, regexes on the hottest execution paths, etc.)

\paragraph{Exploring Equivalence Class Models}
We looked at 5 equivalence classes, each with 3 to 5 nodes.  Future work could

\paragraph{Exploring Understandability Impact}
In another study, we did a survey where software professionals indicated that understandability of regexes they find in source code is a major pain point.  In this study, our participants indicated that they read about twice as many regexes as they compose.  What is the impact on maintainers, developers and contributors to open-source projects of not being able to understand a regex that they find in the code they are working with?  Presumably this is a frustrating experience - how much does a confusing regex slow down a software professional?  What bugs or other negative factors can be attributed to or associated with regexes that are difficult to understand.  How often does this happen and in what settings?  Future work could tailor an in-depth exploration of the overall costs of confusing regexes and the potential benefits of refactoring or other treatments for confusing regexes.

\paragraph{Exploring Refactoring Applications}

\paragraph{DBB Group}

A particular community (like Mozilla or some startup) may want to include regex refactoring into their coding standards.  We anticipate that having one preferred way to express a particular regex may increase regex understandability in the codebase for maintainers, leading to a reduction in errors related to misunderstanding regexes.



\paragraph{Coding Standards for Regexes}
Many organizations enforce coding standards in their repositories to ease understandability.
Presently, we are not aware of coding standards for regular expressions, but this work suggests that enforcing standard representations for various regex constructs could ease comprehension.

%A particular community (like Mozilla or some startup) may want to include regex refactoring into their coding standards.  We anticipate that having one preferred way to express a particular regex may increase regex understandability in the codebase for maintainers, leading to a reduction in errors related to misunderstanding regexes.

\paragraph{Other Refactorings}
The refactorings we suggest in this work are just a starting point as this is the first work to look
at regex refactoring.
Other refactorings exist that deserve further study, such as:
\begin{description}
\item[Single line option]  \verb!'''(.|\n)+'''! is equivalent to \verb!(?s)'''(.)+'''!
\item[Multi line option]  \verb!(?m)G\n! is equivalent to \verb!(?m)G$!
\item[Multi line option]  \verb!(?i)[a-z]! is equivalent to \verb![A-Za-z]!
\item[Backreferences]  \verb!(X)q\1! is equivalent to \verb!(?P<name>X)q\g<name>!
\item[Word Boundaries]  \verb!\bZ! is equivalent to \verb!((?<=\w)(?=\W)|(?<=\W)(?=\w))Z!
\end{description}

\noindent This is not meant to be an exhaustive list as regex languages with richer feature sets may have even more equivalence classes available, but it provides a starting point.

\paragraph{Migration Libraries}
Other opportunities exist to improve the understandability of regexes in existing code bases
by looking for some of the less understandable regex representations, which can be thought of as antipatterns, and refactoring to the more common or understandable representations. Building migration libraries is another direction of future work to ease the manual burden of this process.
%One terribly obvious application of our refactorings is to search existing codebases for regex patterns that are candidates for refactoring, allowing a person to quickly go through a list of possible changes and improve the understandability of the regexes in their codebase.

\paragraph{Finish me...}
Maintainers of code that is intentionally obfuscated for security purposes may want to develop regexes that they understand and then automatically transform them to equivalent but less understandable regexes.

One fundamental concept is when to use regexes for simple parsing, and when to write a full-fledged parser (for example, when parsing HTML).  Regexes that are trying to parse HTML, XML or similar languages could be refactored not into a better regex, but into some code with an equivalent intention that does parsing much better.

In our treatment, we have looked at all ranges as equivalent, all defaults as equivalent, and relied on many such generalizations.  By creating a much more granular model of regular expression refactorings (perhaps treating \verb!\d! and \verb!\w! quite separately), and making sure to carefully evaluate alternative representations of the most frequently used specific patterns (like \verb!\\s*! and \verb!.+!), many more strong and useful refactorings could be identified.



\subsection{Threats to Validity}

\subsubsection{Internal}
We measure understandability of regexes using two metrics, matching and composition. However, these measures may not reflect actual understanding of the regex behavior. For this reason, we chose to use two metrics and present the analysis in the context of reading and writing regexes, but the threat remains.

\todoMid{what about the threat of too few examples per node?}

We treated unsure responses as omissions and did not count those against the participants. Thus, if a participant answered two strings correctly with match/not match, and marked the other three strings as unsure, then this was 2/2 correct, not 2/5.

\subsubsection{External}
Participants in our survey came from MTurk, which may not be representative of people who read and write regexes on a regular basis.

The regexes we used in the evaluation were inspired by those commonly found in Python code, which is just one language that has library support for regexes. Thus, we may have missed opportunities for other refactorings based on how programmers use regexes in other programming languages.

Our community analysis only focuses on the Python language. Note that because the vast majority of regex features are shared across most general programming languages (e.g., Java, C, C\#, or Ruby), a Python {pattern} will (almost always) behave the same when used in other languages, whereas a utilization is not universal in the same way (i.e., it may not compile in other languages, even with small modifications to function and flag names).
As an example, the {\tt re.MULTILINE} flag, or similar, is present in Python, Java, and C\#, but  the Python {\tt re.DOTALL} flag is not present in C\# though it has an equivalent flag in Java.
